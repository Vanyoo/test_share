<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆ†äº«å¡ç‰‡ç”Ÿæˆå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.js"></script>
    <style>
        body {
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        /* é¡¶éƒ¨å›ºå®šé¢„è§ˆåŒºåŸŸ */
        .preview-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            z-index: 100;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .preview-header h3 {
            text-align: center;
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .preview-image {
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            object-fit: contain;
            display: block;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.3s ease;
        }

        .preview-image:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.2);
        }

        .button-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #28a745;
            color: white;
        }

        .btn-primary:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn-secondary {
            background: #007bff;
            color: white;
        }

        .btn-secondary:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
        }

        /* ä¸‹æ–¹å¯æ»šåŠ¨æ“ä½œåŒºåŸŸ */
        .editor-section {
            position: fixed;
            top: 410px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .editor-section::-webkit-scrollbar {
            width: 8px;
        }

        .editor-section::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .editor-section::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }

        .editor-section::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .input-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            border-left: 4px solid #667eea;
        }

        .input-panel h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            min-height: 200px;
            resize: vertical;
            line-height: 1.6;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 15px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .style-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            border-left: 4px solid #28a745;
        }

        .style-panel h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .color-scheme-container {
            margin: 20px 0;
        }

        .color-scheme-container label {
            display: block;
            margin-bottom: 15px;
            font-weight: bold;
            color: #333;
        }

        .color-scheme-selectors {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .scheme-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .scheme-container:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .scheme-container.selected {
            background: rgba(102, 126, 234, 0.15);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #ddd;
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease;
        }

        .scheme-container.selected .circle {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .scheme-label {
            font-size: 12px;
            margin-top: 8px;
            color: #666;
            font-weight: 500;
        }

        .font-container {
            margin: 20px 0;
        }

        .font-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .font-container select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }

        .font-container select:focus {
            outline: none;
            border-color: #28a745;
        }

        .loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10001;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-family: sans-serif;
            font-size: 14px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            .editor-section {
                grid-template-columns: 1fr;
                gap: 20px;
                top: 410px;
            }

            .preview-image {
                max-height: 250px;
            }

            .button-container {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>

<body>
    <!-- é¡¶éƒ¨å›ºå®šé¢„è§ˆåŒºåŸŸ -->
    <div class="preview-header">
        <h3>ğŸ–¼ï¸ å®æ—¶é¢„è§ˆ</h3>
        <img id="preview-image" class="preview-image" alt="é¢„è§ˆå›¾ç‰‡">
        <div class="button-container">
            <button id="regenerate-btn" class="btn btn-primary">ğŸ”„ é‡æ–°ç”Ÿæˆ</button>
            <button id="download-btn" class="btn btn-secondary">ğŸ’¾ ä¸‹è½½å›¾ç‰‡</button>
        </div>
    </div>

    <!-- ä¸‹æ–¹å¯æ»šåŠ¨æ“ä½œåŒºåŸŸ -->
    <div class="editor-section">
        <!-- å·¦ä¾§ï¼šå†…å®¹ç¼–è¾‘ -->
        <div class="input-panel">
            <h3>ğŸ“ å†…å®¹ç¼–è¾‘</h3>

            <div class="input-group">
                <label for="source-input">å‡ºå¤„ï¼š</label>
                <input type="text" id="source-input" value="ç¤ºä¾‹æ–‡æ¡£" placeholder="è¯·è¾“å…¥å‡ºå¤„ï¼Œä¾‹å¦‚ï¼šã€Šäººç±»ç®€å²ã€‹">
            </div>

            <div class="input-group">
                <label for="author-input">ä½œè€…ï¼š</label>
                <input type="text" id="author-input" value="-" placeholder="è¯·è¾“å…¥ä½œè€…ï¼Œä¾‹å¦‚ï¼šå°¤ç“¦å°”Â·èµ«æ‹‰åˆ©">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="editable-checkbox" checked>
                <label for="editable-checkbox">å…è®¸ç¼–è¾‘æ–‡æœ¬å†…å®¹</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="markdown-checkbox">
                <label for="markdown-checkbox">Markdownæ ¼å¼</label>
            </div>

            <div class="input-group">
                <label for="content-textarea">æ–‡æœ¬å†…å®¹ï¼š</label>
                <textarea id="content-textarea" placeholder="è¯·è¾“å…¥è¦åˆ†äº«çš„æ–‡æœ¬å†…å®¹"></textarea>
            </div>
        </div>

        <!-- å³ä¾§ï¼šæ ·å¼è®¾ç½® -->
        <div class="style-panel">
            <h3>ğŸ¨ æ ·å¼è®¾ç½®</h3>

            <div class="color-scheme-container">
                <label>é…è‰²æ–¹æ¡ˆï¼š</label>
                <div class="color-scheme-selectors" id="color-scheme-selectors">
                    <!-- åŠ¨æ€ç”Ÿæˆé…è‰²æ–¹æ¡ˆ -->
                </div>
            </div>

            <div class="font-container">
                <label for="font-selector">å­—ä½“é€‰æ‹©ï¼š</label>
                <select id="font-selector">
                    <!-- åŠ¨æ€ç”Ÿæˆå­—ä½“é€‰é¡¹ -->
                </select>
            </div>
        </div>
    </div>

    <script>
        (function () {
            'use strict';

            // Color schemes data
            const colorSchemes = {
                'scheme1': {
                    name: 'æ¸©æš–ç±³è‰²',
                    background: '#FFF9F3',
                    primaryTextColor: '#3A2C21',
                    sourceTextColor: '#403B36',
                    authorTextColor: '#67625E'
                },
                'scheme2': {
                    name: 'ç®€æ´ç™½è‰²',
                    background: '#FAFAFA',
                    primaryTextColor: '#3A2C21',
                    sourceTextColor: '#403B36',
                    authorTextColor: '#67625E'
                },
                'scheme3': {
                    name: 'ä¼˜é›…æ·±è‰²',
                    background: '#121212',
                    primaryTextColor: '#E8D7B0',
                    sourceTextColor: '#DCD2AE',
                    authorTextColor: '#ACA694'
                },
                'scheme4': {
                    name: 'æ¸…æ–°ç»¿è‰²',
                    background: '#F2F7F0',
                    primaryTextColor: '#3A2C21',
                    sourceTextColor: '#403B36',
                    authorTextColor: '#67625E'
                }
            };

            let loadingOverlay = null;
            let currentColorScheme = 'scheme1';
            let currentFont = '"Segoe UI", "Microsoft YaHei", sans-serif';
            let isContentEditable = true;
            let isMarkdown = false; // Whether content is Markdown format

            // é»˜è®¤æ–‡æœ¬å†…å®¹
            const defaultText = "åœ¨è¿™ä¸ªå¿«é€Ÿå˜åŒ–çš„æ—¶ä»£ï¼ŒæŒç»­å­¦ä¹ å’Œé€‚åº”èƒ½åŠ›å˜å¾—æ¯”ä»¥å¾€ä»»ä½•æ—¶å€™éƒ½é‡è¦ã€‚æ­£å¦‚å²è’‚å¤«Â·ä¹”å¸ƒæ–¯æ‰€è¯´ï¼š\"Stay hungry, stay foolishã€‚\"è¿™ç§æ±‚çŸ¥è‹¥æ¸´çš„å¿ƒæ€ï¼Œå°†å¸®åŠ©æˆ‘ä»¬åœ¨æ¿€çƒˆçš„ç«äº‰ä¸­è„±é¢–è€Œå‡ºã€‚\n\nå­¦ ä¹ ä¸ä»…ä»…æ˜¯è·å–ä¿¡æ¯ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´æ–¹å¼çš„åŸ¹å…»ã€‚é€šè¿‡ä¸æ–­å­¦ä¹ ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£ä¸–ç•Œï¼Œåšå‡ºæ˜æ™ºçš„å†³ç­–ï¼Œåˆ›é€ å±äºè‡ªå·±çš„ä»·å€¼ã€‚";

            // Show toast notification
            function showToast(message, duration = 3000) {
                let toastContainer = document.querySelector('.toast-container');
                if (!toastContainer) {
                    toastContainer = document.createElement('div');
                    toastContainer.className = 'toast-container';
                    document.body.appendChild(toastContainer);
                }

                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                toastContainer.appendChild(toast);

                // Force reflow
                void toast.offsetWidth;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                        toast.remove();
                        if (toastContainer.children.length === 0) {
                            toastContainer.remove();
                        }
                    }, { once: true });
                }, duration);
            }

            // Show loading overlay
            function showLoading() {
                if (loadingOverlay) {
                    loadingOverlay.remove();
                }

                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'loading-indicator';

                const spinner = document.createElement('div');
                spinner.className = 'loading-spinner';

                loadingOverlay.appendChild(spinner);
                document.body.appendChild(loadingOverlay);
            }

            // Hide loading overlay
            function hideLoading() {
                if (loadingOverlay) {
                    loadingOverlay.remove();
                    loadingOverlay = null;
                }
            }

            // Create quote image using direct canvas operations
            async function createQuoteImage(text, source, author, colorScheme) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                const width = 600;
                canvas.width = width * 2;
                ctx.textAlign = 'center';
                ctx.fillStyle = colorScheme.primaryTextColor;
                ctx.scale(2, 2);

                const now = new Date();
                const day = now.getDate();
                const month = now.toLocaleString('en-US', { month: 'long' }).toUpperCase();
                const year = now.getFullYear();
                const weekday = now.toLocaleDateString('zh-CN', { weekday: 'long' });

                const headerTopMargin = 60;
                const dayFontSize = 120;
                const monthYearFontSize = 32;
                const weekdayFontSize = 18;
                const separatorHeight = 20;
                const headerSpacing = 20;
                const textPadding = 40;
                const contentFontSize = 20;
                const sourceFontSize = 18;

                // Check if content is Markdown
                if (isMarkdown) {
                    // Convert Markdown to HTML
                    const htmlContent = marked.parse(text);

                    // Create a temporary container to measure HTML content
                    const tempContainer = document.createElement('div');
                    tempContainer.innerHTML = htmlContent;
                    tempContainer.style.fontFamily = currentFont;
                    tempContainer.style.fontSize = `${contentFontSize}px`;
                    tempContainer.style.color = colorScheme.primaryTextColor;
                    tempContainer.style.backgroundColor = colorScheme.background;
                    tempContainer.style.padding = '20px';
                    tempContainer.style.boxSizing = 'border-box';
                    tempContainer.style.width = `${width}px`;
                    tempContainer.style.position = 'absolute';
                    tempContainer.style.left = '-9999px';
                    tempContainer.style.top = '-9999px';
                    document.body.appendChild(tempContainer);

                    // Measure the height of the HTML content
                    const htmlHeight = tempContainer.offsetHeight;
                    document.body.removeChild(tempContainer);

                    const headerHeight = headerTopMargin + dayFontSize + headerSpacing + monthYearFontSize +
                        headerSpacing + weekdayFontSize + separatorHeight + textPadding;

                    const dayY = headerTopMargin + dayFontSize;
                    const monthYearY = dayY + headerSpacing + monthYearFontSize;
                    const weekdayY = monthYearY + headerSpacing + weekdayFontSize;
                    const separatorY = weekdayY + separatorHeight;

                    ctx.font = `${contentFontSize}px ${currentFont}`;
                    ctx.textAlign = 'left';

                    // Source dimensions
                    ctx.font = `${sourceFontSize}px ${currentFont}`;
                    ctx.textAlign = 'center';
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    const sourceMaxWidth = 300;
                    const { lines: sourceLines, textMaxWidth: sourceTextMaxWidth } = wrapText(ctx, source, sourceMaxWidth);
                    const sourceHeight = sourceLines.length * 30;

                    const footerBottomMargin = 60;
                    const authorFontSize = 18;
                    const footerSpacing = 15;
                    const footerHeight = textPadding + sourceFontSize + footerSpacing + authorFontSize + footerBottomMargin + sourceHeight;

                    const totalHeight = headerHeight + htmlHeight / 2 + footerHeight;
                    canvas.height = totalHeight * 2;

                    ctx.setTransform(2, 0, 0, 2, 0, 0);

                    ctx.fillStyle = colorScheme.background;
                    ctx.fillRect(0, 0, width, totalHeight);

                    ctx.fillStyle = colorScheme.primaryTextColor;
                    ctx.textAlign = 'center';

                    ctx.font = `bold ${dayFontSize}px ${currentFont}`;
                    ctx.fillText(day, width / 2, dayY);

                    ctx.font = `${monthYearFontSize}px ${currentFont}`;
                    ctx.fillText(`${month} ${year}`, width / 2, monthYearY);

                    ctx.font = `${weekdayFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    ctx.fillText(weekday, width / 2, weekdayY);

                    ctx.beginPath();
                    ctx.moveTo(width / 2 - 40, separatorY);
                    ctx.lineTo(width / 2 + 40, separatorY);
                    ctx.strokeStyle = colorScheme.primaryTextColor;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    const textStartY = separatorY + 40;

                    ctx.font = `${contentFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.primaryTextColor;
                    ctx.textAlign = 'left';

                    // Parse HTML content and draw it on canvas
                    drawHtmlContent(ctx, htmlContent, 40, textStartY, 520, htmlHeight / 2, colorScheme);

                    ctx.textAlign = 'center';
                    const sourceY = totalHeight - footerBottomMargin - authorFontSize - footerSpacing - sourceHeight;
                    const authorY = totalHeight - footerBottomMargin;

                    ctx.font = `${sourceFontSize}px ${currentFont}`;
                    ctx.textAlign = 'center';
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    const sourceLeftMargin = width / 2;
                    addQuoteInSourceLines(sourceLines).forEach((line, index) => {
                        ctx.fillText(line, sourceLeftMargin, sourceY + index * 30);
                    });

                    ctx.font = `${authorFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.authorTextColor;
                    ctx.fillText(author, width / 2, authorY);

                    return canvas;
                } else {
                    // Use the original text rendering logic
                    const headerHeight = headerTopMargin + dayFontSize + headerSpacing + monthYearFontSize +
                        headerSpacing + weekdayFontSize + separatorHeight + textPadding;

                    const dayY = headerTopMargin + dayFontSize;
                    const monthYearY = dayY + headerSpacing + monthYearFontSize;
                    const weekdayY = monthYearY + headerSpacing + weekdayFontSize;
                    const separatorY = weekdayY + separatorHeight;

                    ctx.font = `${contentFontSize}px ${currentFont}`;
                    ctx.textAlign = 'left';

                    const maxWidth = 520;
                    const { lines, textMaxWidth } = wrapText(ctx, text, maxWidth);
                    const lineHeight = 30;
                    const textHeight = lines.length * lineHeight;

                    ctx.font = `${sourceFontSize}px ${currentFont}`;
                    ctx.textAlign = 'center';
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    const sourceMaxWidth = 300;
                    const { lines: sourceLines, textMaxWidth: sourceTextMaxWidth } = wrapText(ctx, source, sourceMaxWidth);
                    const sourceHeight = sourceLines.length * lineHeight;

                    const footerBottomMargin = 60;
                    const authorFontSize = 18;
                    const footerSpacing = 15;
                    const footerHeight = textPadding + sourceFontSize + footerSpacing + authorFontSize + footerBottomMargin + sourceHeight;

                    const totalHeight = headerHeight + textHeight + footerHeight;
                    canvas.height = totalHeight * 2;

                    ctx.setTransform(2, 0, 0, 2, 0, 0);

                    ctx.fillStyle = colorScheme.background;
                    ctx.fillRect(0, 0, width, totalHeight);

                    ctx.fillStyle = colorScheme.primaryTextColor;
                    ctx.textAlign = 'center';

                    ctx.font = `bold ${dayFontSize}px ${currentFont}`;
                    ctx.fillText(day, width / 2, dayY);

                    ctx.font = `${monthYearFontSize}px ${currentFont}`;
                    ctx.fillText(`${month} ${year}`, width / 2, monthYearY);

                    ctx.font = `${weekdayFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    ctx.fillText(weekday, width / 2, weekdayY);

                    ctx.beginPath();
                    ctx.moveTo(width / 2 - 40, separatorY);
                    ctx.lineTo(width / 2 + 40, separatorY);
                    ctx.strokeStyle = colorScheme.primaryTextColor;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    const textStartY = separatorY + (totalHeight - headerHeight - footerHeight - textHeight) / 2 + lineHeight + textPadding;

                    ctx.font = `${contentFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.primaryTextColor;
                    ctx.textAlign = 'left';
                    const leftMargin = (width - textMaxWidth) / 2;
                    lines.forEach((line, index) => {
                        ctx.fillText(line, leftMargin, textStartY + index * lineHeight);
                    });

                    ctx.textAlign = 'center';
                    const sourceY = totalHeight - footerBottomMargin - authorFontSize - footerSpacing - sourceHeight;
                    const authorY = totalHeight - footerBottomMargin;

                    ctx.font = `${sourceFontSize}px ${currentFont}`;
                    ctx.textAlign = 'center';
                    ctx.fillStyle = colorScheme.sourceTextColor;
                    const sourceLeftMargin = width / 2;
                    addQuoteInSourceLines(sourceLines).forEach((line, index) => {
                        ctx.fillText(line, sourceLeftMargin, sourceY + index * lineHeight);
                    });

                    ctx.font = `${authorFontSize}px ${currentFont}`;
                    ctx.fillStyle = colorScheme.authorTextColor;
                    ctx.fillText(author, width / 2, authorY);

                    return canvas;
                }
            }

            // Function to draw HTML content on canvas
            function drawHtmlContent(ctx, htmlContent, x, y, maxWidth = 520, maxHeight, colorScheme, lineHeight = 30) {
                // Create a temporary container to parse HTML
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = htmlContent;
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.top = '-9999px';
                tempContainer.style.width = `${maxWidth}px`;
                tempContainer.style.fontFamily = currentFont;
                tempContainer.style.fontSize = ctx.font.replace(/^[0-9]*\.?[0-9]*px/, '').trim();
                tempContainer.style.color = colorScheme.primaryTextColor;
                tempContainer.style.backgroundColor = colorScheme.background;
                document.body.appendChild(tempContainer);

                function calculateLineHeight(fontSize, tagName) {
                    switch (tagName) {
                        case 'h1':
                            return {
                                lineHeight: fontSize * 1.5 * 1.2,
                                preLineHeight: fontSize * 1.5 * 1.2 * 0.5
                            }
                        case 'h2':
                            return {
                                lineHeight: fontSize * 1.5 * 1.3,
                                preLineHeight: fontSize * 1.5 * 1.3 * 0.35
                            }
                        case 'h3':
                            return {
                                lineHeight: fontSize * 1.5 * 1.4,
                                preLineHeight: fontSize * 1.5 * 1.4 * 0.25
                            }
                        default:
                            return {
                                lineHeight: fontSize * 1.5,
                                preLineHeight: 0
                            }
                    }
                }

                // Recursive function to draw elements
                function drawElement(element, currentX, currentY, isParentBlockElement = false, isPreviousNodeBlockElement = false, preLineHeight = 0, postXOffset = 0) {
                    // Check if element is valid
                    if (!element) {
                        return { x: currentX, y: currentY };
                    }

                    // Get computed style safely
                    let computedStyle;
                    try {
                        computedStyle = element.nodeType === Node.ELEMENT_NODE ? window.getComputedStyle(element) : null;
                    } catch (e) {
                        // If we can't get computed style, use default values
                        computedStyle = null;
                    }

                    const tagName = element.tagName ? element.tagName.toLowerCase() : '';

                    // Apply styles
                    ctx.save();
                    ctx.textBaseline = 'middle';
                    let font = ctx.font;
                    let fillStyle = colorScheme.primaryTextColor;
                    let nextPreLineHeight = 0;
                    let childPostLineXOffset = 0;

                    if (computedStyle) {
                        font = computedStyle.font;
                        fillStyle = computedStyle.color || colorScheme.primaryTextColor;

                        let computeFontSize = parseInt(computedStyle.fontSize);
                        let computeFontFamily = computedStyle.fontFamily;
                        let lineHeightResult = calculateLineHeight(computeFontSize, tagName);
                        lineHeight = lineHeightResult.lineHeight;
                        nextPreLineHeight = lineHeightResult.preLineHeight;
                        // Handle different elements
                        if (tagName === 'strong' || tagName === 'b') {
                            font = `bold ${computedStyle.fontSize} ${computeFontFamily}`;
                        } else if (tagName === 'em' || tagName === 'i') {
                            font = `italic ${computedStyle.fontSize} ${computeFontFamily}`;
                            childPostLineXOffset = computeFontSize * 0.2; // Italic offset
                        } else if (tagName === 'h1') {
                            font = `bold ${computeFontSize * 1.5}px ${computeFontFamily}`;
                        } else if (tagName === 'h2') {
                            font = `bold ${computeFontSize * 1.3}px ${computeFontFamily}`;
                        } else if (tagName === 'h3') {
                            font = `bold ${computeFontSize * 1.1}px ${computeFontFamily}`;
                        }
                    }

                    ctx.font = font;
                    ctx.fillStyle = fillStyle;
                    ctx.textAlign = 'left';
                    let isCurrentBlockElement = false;

                    // Draw text content
                    if (element.nodeType === Node.TEXT_NODE) {
                        const text = element.textContent || '';
                        if (text.trim()) {
                            // Split text by newlines to preserve line breaks
                            const textLines = text.split('\n');
                            let lineCurrentY = currentY + preLineHeight;
                            let tmpCurrentX = currentX;

                            textLines.forEach((textLine, index) => {
                                if (textLine.trim()) { // Draw even empty lines except possibly the first
                                    const { lines, textMaxWidth } = x === currentX ? wrapText(ctx, textLine, maxWidth) : wrapTextWithXOffset(ctx, textLine, maxWidth, currentX, x);
                                    lines.forEach((line, iindex) => {
                                        ctx.fillText(line, currentX, lineCurrentY);
                                        if (iindex !== lines.length - 1) {
                                            currentX = x; // æœ€åˆå§‹ä½ç½®
                                        }
                                        lineCurrentY += lineHeight; // Line height
                                    });
                                    // è®°å½•æœ€åä¸€è¡Œçš„ç»“æŸä½ç½®
                                    const metrics = ctx.measureText(lines[lines.length - 1]);
                                    tmpCurrentX = currentX + metrics.width
                                } else {
                                    lineCurrentY += lineHeight; // Still add height for empty lines
                                }
                            });

                            lineCurrentY -= lineHeight;
                            currentY = lineCurrentY;
                            currentX = tmpCurrentX + postXOffset;

                        }
                    } else if (element.nodeType === Node.ELEMENT_NODE) {
                        // Handle child elements
                        let childCurrentX = currentX ;
                        let childCurrentY = currentY;

                        // Define block-level elements that should have line breaks
                        const blockElements = ['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'br', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'pre', 'hr', 'table', 'form', 'fieldset', 'legend', 'details', 'summary'];
                        isCurrentBlockElement = blockElements.includes(tagName);

                        // Process children
                        let isPreviousNodeBlock = false;
                        for (let child of element.childNodes) {
                            const result = drawElement(child, childCurrentX, childCurrentY, isCurrentBlockElement, isPreviousNodeBlock, nextPreLineHeight, childPostLineXOffset);
                            childCurrentX = result.x;
                            childCurrentY = result.y;
                            isPreviousNodeBlock = result.isBlock;
                        }

                        // For block elements, add a line break at the beginning
                        if (isCurrentBlockElement) {
                            childCurrentY += lineHeight; // Add line height before block element content
                            childCurrentX = x; // Reset X position for new line
                        }

                        currentY = Math.max(currentY, childCurrentY);
                        currentX = childCurrentX;
                    }

                    ctx.restore();
                    return { x: currentX, y: currentY, isBlock: isCurrentBlockElement };
                }

                /**
                 * è¿”å›åœ¨ç»™å®šå®½åº¦ maxWidth ä¹‹å†…ï¼Œèƒ½å¤Ÿå®Œæ•´ç»˜åˆ¶çš„æœ€é•¿æ–‡æœ¬å‰ç¼€ã€‚
                 * å…¼å®¹ä¸­è‹±æ–‡ã€emojiã€å…¶ä»– Unicode ç ç‚¹ï¼ˆä¸ä¼šæŠŠä»£ç†å¯¹æˆªæˆåŠä¸ªï¼‰ã€‚
                 *
                 * @param {CanvasRenderingContext2D} ctx   å·²è®¾ç½®å¥½ fontã€style ç­‰å±æ€§çš„ canvas ä¸Šä¸‹æ–‡
                 * @param {string} text                     å¾…è£å‰ªçš„å®Œæ•´æ–‡å­—ï¼ˆå¯èƒ½å«ä¸­è‹±æ–‡ã€emoji ç­‰ï¼‰
                 * @param {number} maxWidth                 ç›®æ ‡å®½åº¦ï¼ˆåƒç´ ï¼‰
                 * @returns {string}                        èƒ½å¤Ÿå®Œæ•´æ˜¾ç¤ºçš„æœ€é•¿å‰ç¼€ï¼›è‹¥ width å°äºé¦–å­—ç¬¦å®½åº¦åˆ™è¿”å›ç©ºä¸²
                 */
                function fitTextPrefix(ctx, text, maxWidth) {
                    if (maxWidth <= 0) return '';
                    if (!text) return '';
                    // æŠŠå­—ç¬¦ä¸²æ‹†æˆã€ŒUnicode ç ç‚¹ã€æ•°ç»„ï¼Œé¿å…æŠŠ surrogate pairï¼ˆå¦‚ emojiï¼‰æˆªæˆåŠä¸ª
                    const chars = Array.from(text);          // å¦‚ ["a","ä¸­","ğŸ˜", ...]
                    const totalLen = chars.length;
                    // æ•´ä½“èƒ½æ”¾ä¸‹å°±ç›´æ¥è¿”å›
                    if (ctx.measureText(text).width <= maxWidth) {
                        return text;
                    }
                    // äºŒåˆ†æŸ¥æ‰¾æœ€é•¿å¯æ”¾çš„å­—ç¬¦æ•°
                    let low = 0;        // å·²ç¡®è®¤å¯ä»¥æ”¾ä¸‹çš„å­—ç¬¦æ•°
                    let high = totalLen; // ä¸Šç•Œï¼ˆå³é—­åŒºé—´ï¼‰
                    while (low < high) {
                        // å–ä¸Šä¸­ä½æ•°ï¼Œé˜²æ­¢ low ä¸ high ç›¸å·® 1 æ—¶æ­»å¾ªç¯
                        const mid = Math.floor((low + high + 1) / 2);
                        const candidate = chars.slice(0, mid).join('');
                        const w = ctx.measureText(candidate).width;
                        if (w <= maxWidth) {
                            low = mid;        // è¿™æ®µå¯ä»¥æ¥å—ï¼Œç»§ç»­å¾€å³
                        } else {
                            high = mid - 1;   // è¶…å‡ºå®½åº¦ï¼Œå¾€å·¦æ”¶æ•›
                        }
                    }
                    // low ä¸ºæ»¡è¶³å®½åº¦é™åˆ¶çš„æœ€å¤§å­—ç¬¦æ•°
                    return chars.slice(0, low).join('');
                }

                // Simple text wrapping function
                /**
                *
                * @param {CanvasRenderingContext2D} context   å·²è®¾ç½®å¥½ fontã€style ç­‰å±æ€§çš„ canvas ä¸Šä¸‹æ–‡
                * @param {string} text                        å¾…è£å‰ªçš„å®Œæ•´æ–‡å­—ï¼ˆå¯èƒ½å«ä¸­è‹±æ–‡ã€emoji ç­‰ï¼‰
                * @param {number} maxWidth                    æœ€å¤§å®½åº¦ï¼ˆåƒç´ ï¼‰
                * @param {number} x                           å…‰æ ‡ä½ç½®ï¼ˆåƒç´ ï¼‰
                * @param {number} standardX                   æ ‡å‡†å…‰æ ‡èµ·å§‹ï¼ˆåƒç´ ï¼‰
                */
                function wrapTextWithXOffset(context, text, maxWidth, x, standardX) {
                    if (x === standardX) {
                        return wrapText(context, text, maxWidth);
                    } else {
                        const maxStr = fitTextPrefix(context, text, maxWidth - x);
                        let { lines, textMaxWidth } = {};
                        if (maxStr.length === text.length) {
                            return wrapText(ctx, text, maxWidth)
                        } else {
                            let { lines, textMaxWidth } = wrapText(ctx, text.substring(maxStr.length), maxWidth);
                            lines.unshift(maxStr);
                            return { lines, textMaxWidth }
                        }
                    }
                }

                // Start drawing from the root element
                drawElement(tempContainer, x, y, false, false);

                // Clean up
                document.body.removeChild(tempContainer);
            }

            // Add ã€Šã€‹ around source lines
            function addQuoteInSourceLines(lines) {
                if (lines.length === 0) {
                    return lines;
                }
                const modifiedLines = [...lines];
                modifiedLines[0] = `ã€Š${modifiedLines[0]}`;
                modifiedLines[modifiedLines.length - 1] += 'ã€‹';
                return modifiedLines;
            }

            // Helper function to wrap text
            function wrapText(context, text, maxWidth) {
                const lines = [];
                const paragraphs = text.split('\n');
                let textMaxWidth = 0;

                paragraphs.forEach(paragraph => {
                    if (/[\u4e00-\u9fa5]/.test(paragraph)) {
                        let line = '';
                        for (let i = 0; i < paragraph.length; i++) {
                            const char = paragraph[i];
                            const testLine = line + char;
                            const metrics = context.measureText(testLine);
                            const testWidth = metrics.width;

                            if (testWidth > maxWidth && line !== '') {
                                const lineWidth = context.measureText(line).width;
                                lines.push(line);
                                textMaxWidth = Math.max(textMaxWidth, lineWidth);
                                line = char;
                            } else {
                                line = testLine;
                            }
                        }
                        if (line !== '') {
                            const lineWidth = context.measureText(line).width;
                            lines.push(line);
                            textMaxWidth = Math.max(textMaxWidth, lineWidth);
                        }
                    } else {
                        let line = '';
                        const words = paragraph.split(' ');

                        words.forEach(word => {
                            const testLine = line + word + ' ';
                            const metrics = context.measureText(testLine);
                            const testWidth = metrics.width;

                            if (testWidth > maxWidth && line !== '') {
                                const lineWidth = context.measureText(line).width;
                                lines.push(line);
                                textMaxWidth = Math.max(textMaxWidth, lineWidth);
                                line = word + ' ';
                            } else {
                                line = testLine;
                            }
                        });

                        if (line !== '') {
                            const trimmedLine = line.trim();
                            const lineWidth = context.measureText(trimmedLine).width;
                            lines.push(trimmedLine);
                            textMaxWidth = Math.max(textMaxWidth, lineWidth);
                        }
                    }
                });

                return { lines, textMaxWidth };
            }

            // Function to get available fonts
            function getAvailableFonts() {
                const commonFonts = [
                    '"Segoe UI", "Microsoft YaHei", sans-serif',
                    'PingFangSC, sans-serif',
                    'Arial, sans-serif',
                    '"Times New Roman", Times, serif',
                    'Georgia, serif',
                    'Verdana, sans-serif',
                    '"Courier New", Courier, monospace',
                    'Tahoma, sans-serif',
                    '"Trebuchet MS", sans-serif',
                    '"Arial Black", sans-serif',
                    'Impact, sans-serif',
                    '"Lucida Console", Monaco, monospace'
                ];

                return [...new Set(commonFonts)];
            }

            // Initialize color scheme selectors
            function initializeColorSchemes() {
                const selectorsContainer = document.getElementById('color-scheme-selectors');

                Object.keys(colorSchemes).forEach(key => {
                    const scheme = colorSchemes[key];

                    const schemeContainer = document.createElement('div');
                    schemeContainer.className = 'scheme-container';
                    schemeContainer.dataset.scheme = key;

                    const circle = document.createElement('div');
                    circle.className = 'circle';

                    const bgHalf = document.createElement('div');
                    bgHalf.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 50%;
                        background: ${scheme.background};
                    `;

                    const textHalf = document.createElement('div');
                    textHalf.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        width: 100%;
                        height: 50%;
                        background: ${scheme.primaryTextColor};
                    `;

                    circle.appendChild(bgHalf);
                    circle.appendChild(textHalf);

                    const label = document.createElement('div');
                    label.textContent = scheme.name;
                    label.className = 'scheme-label';

                    schemeContainer.appendChild(circle);
                    schemeContainer.appendChild(label);
                    selectorsContainer.appendChild(schemeContainer);

                    // Add click event
                    schemeContainer.addEventListener('click', function () {
                        currentColorScheme = key;

                        // Update selection
                        document.querySelectorAll('.scheme-container').forEach(container => {
                            container.classList.remove('selected');
                        });
                        this.classList.add('selected');

                        // Regenerate preview
                        regeneratePreview();
                    });
                });

                // Set initial selection
                document.querySelector(`[data-scheme="${currentColorScheme}"]`).classList.add('selected');
            }

            // Initialize font selector
            function initializeFontSelector() {
                const fontSelect = document.getElementById('font-selector');
                const commonFonts = getAvailableFonts();

                commonFonts.forEach(font => {
                    const option = document.createElement('option');
                    option.value = font;
                    option.textContent = font.split(',')[0].replace(/"/g, '');
                    if (font === currentFont) {
                        option.selected = true;
                    }
                    fontSelect.appendChild(option);
                });

                fontSelect.addEventListener('change', function () {
                    currentFont = this.value;
                    regeneratePreview();
                });
            }

            // Regenerate preview image
            async function regeneratePreview() {
                showLoading();

                const sourceInput = document.getElementById('source-input');
                const authorInput = document.getElementById('author-input');
                const contentTextarea = document.getElementById('content-textarea');

                const source = sourceInput.value || 'ç¤ºä¾‹æ–‡æ¡£';
                const author = authorInput.value || '-';
                const content = contentTextarea.value || defaultText;

                try {
                    const canvas = await createQuoteImage(content, source, author, colorSchemes[currentColorScheme]);
                    const imageUrl = canvas.toDataURL('image/png');
                    document.getElementById('preview-image').src = imageUrl;

                    showToast('é¢„è§ˆå·²æ›´æ–°ï¼');
                } catch (error) {
                    console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
                    showToast('ç”Ÿæˆå›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚');
                } finally {
                    hideLoading();
                }
            }

            // Download image
            function downloadImage() {
                const img = document.getElementById('preview-image');
                const link = document.createElement('a');
                link.href = img.src;
                link.download = `quote_${new Date().getDate()}_${new Date().toLocaleString('en-US', { month: 'long' })}_${new Date().getFullYear()}.png`;
                link.target = '_blank';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('å›¾ç‰‡å·²å¼€å§‹ä¸‹è½½ï¼');
            }

            // Initialize event listeners
            function initializeEventListeners() {
                // Editable checkbox
                const editableCheckbox = document.getElementById('editable-checkbox');
                const contentTextarea = document.getElementById('content-textarea');

                editableCheckbox.addEventListener('change', function () {
                    isContentEditable = this.checked;
                    contentTextarea.disabled = !this.checked;
                    contentTextarea.style.opacity = this.checked ? '1' : '0.6';
                });

                // Markdown checkbox
                const markdownCheckbox = document.getElementById('markdown-checkbox');
                markdownCheckbox.addEventListener('change', function () {
                    isMarkdown = this.checked;
                    regeneratePreview();
                });

                // Auto-regenerate on input change
                const inputs = ['source-input', 'author-input', 'content-textarea'];
                inputs.forEach(inputId => {
                    document.getElementById(inputId).addEventListener('input', debounce(() => {
                        regeneratePreview();
                    }, 500));
                });

                // Regenerate button
                document.getElementById('regenerate-btn').addEventListener('click', regeneratePreview);

                // Download button
                document.getElementById('download-btn').addEventListener('click', downloadImage);
            }

            // Debounce function for input events
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Initialize application
            function initialize() {
                // Set default content
                document.getElementById('content-textarea').value = defaultText;

                // Initialize UI components
                initializeColorSchemes();
                initializeFontSelector();
                initializeEventListeners();

                // Generate initial preview
                regeneratePreview();
            }

            // Start the application
            initialize();

        })();
    </script>
</body>

</html>